/**
 * Problem Spec V1 - Schema for generated problem specifications
 *
 * This defines the shape of problems generated by the LLM.
 * All generated problems must conform to this schema before approval.
 */

import { z } from 'zod';

/**
 * Test Case schema - individual test for a problem
 */
/**
 * Generated Test Case schema - for problem generator
 * Named differently from the main TestCase to avoid conflicts
 */
export const zGeneratedTestCase = z.object({
  input: z.string().min(1, 'Input is required'),
  expectedOutput: z.string().min(1, 'Expected output is required'),
  explanation: z.string().optional(),
  isHidden: z.boolean().default(false),
});

export type GeneratedTestCase = z.infer<typeof zGeneratedTestCase>;

/**
 * Difficulty levels for generated problems
 */
export const zProblemDifficulty = z.enum(['EASY', 'MEDIUM', 'HARD', 'EXPERT']);

export type ProblemDifficulty = z.infer<typeof zProblemDifficulty>;

/**
 * Example in problem statement
 */
export const zProblemExample = z.object({
  input: z.string().min(1),
  output: z.string().min(1),
  explanation: z.string().optional(),
});

export type ProblemExample = z.infer<typeof zProblemExample>;

/**
 * Problem Statement section
 */
export const zProblemStatement = z.object({
  prompt: z.string().min(50, 'Problem prompt must be at least 50 characters'),
  constraints: z.array(z.string()).min(1, 'At least one constraint required'),
  examples: z.array(zProblemExample).min(1, 'At least one example required'),
});

export type ProblemStatement = z.infer<typeof zProblemStatement>;

/**
 * Input/Output format specification
 */
export const zIOSpec = z.object({
  inputFormat: z.string().min(10, 'Input format description required'),
  outputFormat: z.string().min(10, 'Output format description required'),
  signature: z.string().optional(), // Function signature if applicable
});

export type IOSpec = z.infer<typeof zIOSpec>;

/**
 * Test suite - public and hidden tests
 */
export const zGeneratedTestSuite = z.object({
  public: z.array(zGeneratedTestCase).min(2, 'At least 2 public test cases required'),
  hidden: z.array(zGeneratedTestCase).min(3, 'At least 3 hidden test cases required'),
});

export type GeneratedTestSuite = z.infer<typeof zGeneratedTestSuite>;

/**
 * Reference solution outline
 */
export const zReferenceSection = z.object({
  solutionOutline: z.string().min(20, 'Solution outline required'),
  timeComplexity: z.string().regex(/^O\(.*\)$/, 'Time complexity must be in O() notation'),
  spaceComplexity: z.string().regex(/^O\(.*\)$/, 'Space complexity must be in O() notation'),
});

export type ReferenceSection = z.infer<typeof zReferenceSection>;

/**
 * Evidence mapping - maps test cases to concepts they verify
 */
export const zEvidenceMapping = z.object({
  testIndex: z.number().int().min(0),
  concept: z.string().min(1),
});

export type EvidenceMapping = z.infer<typeof zEvidenceMapping>;

/**
 * Coach section - hints and common mistakes for coaching
 */
export const zCoachSection = z.object({
  commonMistakes: z.array(z.string()).min(1, 'At least one common mistake'),
  evidenceMapping: z.array(zEvidenceMapping).optional(),
});

export type CoachSection = z.infer<typeof zCoachSection>;

/**
 * Problem Spec V1 - Complete generated problem specification
 *
 * This is the full schema for a generated coding problem.
 * Generated problems must pass validation against this schema.
 */
export const zProblemSpecV1 = z.object({
  // Identification
  title: z.string().min(5, 'Title must be at least 5 characters').max(100, 'Title must be at most 100 characters'),
  summary: z.string().min(20, 'Summary must be at least 20 characters').max(500, 'Summary must be at most 500 characters'),

  // Classification
  patternIds: z.array(z.string()).min(1, 'At least one pattern required'),
  categories: z.array(z.string()).default([]),
  level: z.number().int().min(0).max(4), // Ladder level (0 = easiest, 4 = hardest)
  difficulty: zProblemDifficulty,

  // Problem content
  statement: zProblemStatement,
  io: zIOSpec,
  tests: zGeneratedTestSuite,
  hints: z.array(z.string()).min(2, 'At least 2 hints required'),

  // Reference and coaching
  reference: zReferenceSection,
  coach: zCoachSection.optional(),
});

export type ProblemSpecV1 = z.infer<typeof zProblemSpecV1>;

/**
 * Validation result for a problem spec
 */
export interface ProblemSpecValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Validate a problem spec against the schema
 */
export function validateProblemSpec(spec: unknown): ProblemSpecValidationResult {
  const result = zProblemSpecV1.safeParse(spec);

  if (result.success) {
    const warnings: string[] = [];

    // Additional validation warnings (not errors)
    const data = result.data;

    // Warn if no coach section
    if (!data.coach) {
      warnings.push('Missing coach section - consider adding common mistakes and evidence mapping');
    }

    // Warn if few public tests
    if (data.tests.public.length < 3) {
      warnings.push('Consider adding more public test cases for better user experience');
    }

    // Warn if hints are too short
    const shortHints = data.hints.filter(h => h.length < 20);
    if (shortHints.length > 0) {
      warnings.push(`${shortHints.length} hint(s) are very short - consider expanding them`);
    }

    return { valid: true, errors: [], warnings };
  }

  // Format Zod errors into readable strings
  const errors = result.error.errors.map(err => {
    const path = err.path.join('.');
    return `${path}: ${err.message}`;
  });

  return { valid: false, errors, warnings: [] };
}

/**
 * Level to difficulty mapping
 */
export const LEVEL_DIFFICULTY_MAP: Record<number, ProblemDifficulty> = {
  0: 'EASY',
  1: 'EASY',
  2: 'MEDIUM',
  3: 'HARD',
  4: 'EXPERT',
};

/**
 * Get expected difficulty for a level
 */
export function getExpectedDifficulty(level: number): ProblemDifficulty {
  return LEVEL_DIFFICULTY_MAP[level] ?? 'MEDIUM';
}
